import {
    TransformHelper
} from "../src/readable_compacts_transform_helper";

import {PreciseProofs, SHA3_256} from "../src/index";

    let transformHashes = (hashes) =>{
        let result = new Array();
        for (let item in hashes)
        {
           if (hashes[item].left != null){
               result.push({"left" : '0x'+ hashes[item].left.toHex()})
           }else if (hashes[item].right != null){
               result.push({"right" : '0x' + hashes[item].right.toHex()})
           }
        }
        return result
    } 
    let Long = require('long');
    let comToLong = (com) =>{
        return new Long(com, 0, true)
    }
    let pairsToLong = (low, high) =>{
        return new Long(low, high, true)
    }
    let comsToLongs = (coms) => {
        let result = new Array
        for (let ii in coms){
            result.push(comToLong(coms[ii]))
        }
        return result
    }

describe('Transform Helper', () => {
    
    let ProtoBuf = require('protobufjs');

    //encoded by golang side for ExampleFilledNestedRepeatedDocument with proof for valueD.valueA.valueA = ValueDAA (compacts mode off)
    let proofHexStrWithReadableName = "120856616c75654441411a2008745defd50b2b3288672f91e579bb36750a7efb43b19019a145758a15e7078322220a20a9b9c8f4100457328a0cf5fa8eab04fbcb8adc418d1c487f345762707652985d2222122058e0dbc3a34450315e43879233a987d458e6541e89c5fa324ae719ef355bf66f22220a20c044e3c925191831b1edf163f40a5ac1b36d5c2e379ab6b34ab1ad0a5596e3213a1476616c7565442e76616c7565412e76616c756541";
    
    //encoded by golang side for ExampleFilledNestedRepeatedDocument with proof for valueD.valueA.valueA = ValueDAA (compacts mode on)
    let proofHexStrWithCompacts ="120856616c75654441411a202f8784d9b2580a7c6835e006c7bb545d8728de228f7b3d5c317991297c8e52ab22220a2073c405f9d1778440c45574cd1975ef546f77b2373f718bf6b2f2204ef45cb53d222212206edd3022b99e902687ba8485fe3d5f9e86717252f3eee955b1116b798fb4c24c22220a20f51fbb85bade17343fd7e1fbfbecadd66154292c5474fcdf21480a2aa6c09c004a050a03040101"
    
    let targetCompacts = comsToLongs([4,1,1]);
    let proofBuild = ProtoBuf.loadJson(require('./proof.json')).build("proofs.Proof");
    let proofWithReadableName = proofBuild.decodeHex(proofHexStrWithReadableName);
    let proofWithCompacts = proofBuild.decodeHex(proofHexStrWithCompacts);

    let hexProof = {
        "property": new TransformHelper(require('./examples.json'), "documents", "NestedRepeatedDocument").compactsToReadableString(comsToLongs([4,1,1])),
        "value": proofWithReadableName.value,
        "salt":  proofWithReadableName.salt.toHex(),
        "hashes": transformHashes(proofWithReadableName.hashes)
    }

    let rootHash = "22153fca4874c6d83471e5cdbbbd76405ba5b659f3763172b5c396f1b983826b"
    it('Proof generated by Golang (with compacts off) should be validated by js side', () => {
       expect(hexProof.property).toEqual('valueD.valueA.valueA')
        expect(hexProof.value).toEqual('ValueDAA')
        expect((new PreciseProofs()).isValidField(hexProof, rootHash)).toEqual(true)
    });

    
    it('Compact Components of proof generated by golang (with compacts on) should  be decoded sucessfully', () => {
        expect(proofWithCompacts.compact_name.components).toEqual(targetCompacts);
    });
    
    let packageName = "test";
    let msgName = "Total";
    let jsonMetaFormat = require('./test_with_import.json');

    let readableName = 'items[513].items[2].cents[5].cents';
    let compacts = comsToLongs([2, 513, 2, 2, 4, 5, 2]);

    let readableNameForStringMap='itemMap[abc].name';
    let compactsForStringMap = comsToLongs([3, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x616263,1]);

    let readableNameForBytesMap='itemMap2[0xabbccd]';
    let compactsForBytesMap = comsToLongs([4, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0xabbccd]);

    let readableNameForUint64Map='itemMap3[567]';
    let compactsForUint64Map = comsToLongs([5, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x353637]);

    let readableNameWithImport = 'items[513].items[2].cents[5].value.name';
    let compactsWithImport = comsToLongs([2, 513, 2, 2, 4, 5, 3, 1]);

    let errorReadableName1 = 'name[513].items[2].cents[5].cents';
    let errorReadableName2 = 'items[513].items[2].cents[5].cen';
    let errorReadableName3 = 'items[51a3].items[2].cents[5].cents';
    let errorReadableName4 = '[51a3].items[2].cents[5].cents';
    let errorReadableName5 = '.items[2].cents[5].cents';

    let errorCompacts1 = comsToLongs([5, 513, 2, 2, 4, 5, 2]);
    let errorCompacts2 = comsToLongs([2, 513, 2, 2, 4, 5, 4]);

    let jsonMetaFormat2 = require('./test_without_import.json');

    it('Empty input lead to empty output', () => {
        expect((new TransformHelper(jsonMetaFormat, packageName, msgName)).compactsToReadableString([])).toEqual('')
        expect((new TransformHelper(jsonMetaFormat, packageName, msgName)).readableStringToCompacts('')).toEqual([]);
    });

    it('should transform successfully when importing other proto def', () => {
        expect((new TransformHelper(jsonMetaFormat, packageName, msgName)).compactsToReadableString(compactsWithImport)).toEqual(readableNameWithImport)
        expect((new TransformHelper(jsonMetaFormat, packageName, msgName)).readableStringToCompacts(readableNameWithImport)).toEqual(compactsWithImport);
    });

    it('string map should work', () => {
        expect((new TransformHelper(jsonMetaFormat, packageName, msgName)).compactsToReadableString(compactsForStringMap)).toEqual(readableNameForStringMap)
        expect((new TransformHelper(jsonMetaFormat, packageName, msgName)).readableStringToCompacts(readableNameForStringMap)).toEqual(compactsForStringMap);
    
    });
    
    it('bytes map should work', () => {
        expect((new TransformHelper(jsonMetaFormat, packageName, msgName)).compactsToReadableString(compactsForBytesMap)).toEqual(readableNameForBytesMap);  
        expect((new TransformHelper(jsonMetaFormat, packageName, msgName)).readableStringToCompacts(readableNameForBytesMap)).toEqual(compactsForBytesMap);
    
    });

    it('int map should work', () => {
        expect((new TransformHelper(jsonMetaFormat, packageName, msgName)).compactsToReadableString(compactsForUint64Map)).toEqual(readableNameForUint64Map);
        expect((new TransformHelper(jsonMetaFormat, packageName, msgName)).readableStringToCompacts(readableNameForUint64Map)).toEqual(compactsForUint64Map);
    });

    it('should transform successfully without importing', () => {
        expect((new TransformHelper(jsonMetaFormat2, packageName, msgName)).compactsToReadableString(compacts)).toEqual(readableName)
        expect((new TransformHelper(jsonMetaFormat2, packageName, msgName)).readableStringToCompacts(readableName)).toEqual(compacts);
    });

    it('mismatched json and package name should throw', () => {
        expect(() => {
            (new TransformHelper(jsonMetaFormat, 'non-existed', msgName)).compactsToReadableString(errorCompacts1);
        }).toThrow();
    });

    it('non-existed message type should throw', () => {
        expect(() => {
            (new TransformHelper(jsonMetaFormat, packageName, 'non-existed')).compactsToReadableString(errorCompacts1);
        }).toThrow();
    });

    it('non exist field id should throw', () => {
        expect(() => {
            (new TransformHelper(jsonMetaFormat, packageName, msgName)).compactsToReadableString(errorCompacts1);
            (new TransformHelper(jsonMetaFormat, packageName, msgName)).compactsToReadableString(errorCompacts2);
        }).toThrow();
    });

    it('non exist field name should throw', () => {
        expect(() => {
            (new TransformHelper(jsonMetaFormat, packageName, msgName)).readableStringToCompacts(errorReadableName1);
            (new TransformHelper(jsonMetaFormat, packageName, msgName)).readableStringToCompacts(errorReadableName2);
        }).toThrow();
    });

    it('repeated format error should throw', () => {
      expect(() => {
          (new TransformHelper(jsonMetaFormat, packageName, msgName)).readableStringToCompacts(errorReadableName3);
      }).toThrow();
    });

    it('format error should throw', () => {
        expect(() => {
          (new TransformHelper(jsonMetaFormat, packageName, msgName)).readableStringToCompacts(errorReadableName4);
          (new TransformHelper(jsonMetaFormat, packageName, msgName)).readableStringToCompacts(errorReadableName5);
        }).toThrow();
    });

});
